{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/michalmizera/Repos/StreamlitMiami/lib/streamlit_lightweight_charts/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _asyncToGenerator from \"/Users/michalmizera/Repos/StreamlitMiami/lib/streamlit_lightweight_charts/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/michalmizera/Repos/StreamlitMiami/lib/streamlit_lightweight_charts/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michalmizera/Repos/StreamlitMiami/lib/streamlit_lightweight_charts/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"/Users/michalmizera/Repos/StreamlitMiami/lib/streamlit_lightweight_charts/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _awaitAsyncGenerator from \"/Users/michalmizera/Repos/StreamlitMiami/lib/streamlit_lightweight_charts/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator\";\nimport _wrapAsyncGenerator from \"/Users/michalmizera/Repos/StreamlitMiami/lib/streamlit_lightweight_charts/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(_fromIterable);\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { toUint8Array, joinUint8Arrays, toUint8ArrayIterator, toUint8ArrayAsyncIterator } from '../util/buffer';\n/** @ignore */\nexport default {\n  fromIterable: function fromIterable(source) {\n    return pump(_fromIterable(source));\n  },\n  fromAsyncIterable: function fromAsyncIterable(source) {\n    return pump(_fromAsyncIterable2(source));\n  },\n  fromDOMStream: function fromDOMStream(source) {\n    return pump(_fromDOMStream2(source));\n  },\n  fromNodeStream: function fromNodeStream(stream) {\n    return pump(_fromNodeStream2(stream));\n  },\n  // @ts-ignore\n  toDOMStream: function toDOMStream(source, options) {\n    throw new Error(\"\\\"toDOMStream\\\" not available in this environment\");\n  },\n  // @ts-ignore\n  toNodeStream: function toNodeStream(source, options) {\n    throw new Error(\"\\\"toNodeStream\\\" not available in this environment\");\n  }\n};\n/** @ignore */\nvar pump = function pump(iterator) {\n  iterator.next();\n  return iterator;\n};\n/** @ignore */\nfunction _fromIterable(source) {\n  var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield, it, _ref, _yield$byteRange;\n  return _regeneratorRuntime().wrap(function _fromIterable$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        byteRange = function _byteRange() {\n          if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n          }\n          var _joinUint8Arrays = joinUint8Arrays(buffers, size);\n          var _joinUint8Arrays2 = _slicedToArray(_joinUint8Arrays, 3);\n          buffer = _joinUint8Arrays2[0];\n          buffers = _joinUint8Arrays2[1];\n          bufferLength = _joinUint8Arrays2[2];\n          return buffer;\n        };\n        threw = false;\n        buffers = [];\n        bufferLength = 0;\n        _context.next = 6;\n        return null;\n      case 6:\n        _yield = _context.sent;\n        cmd = _yield.cmd;\n        size = _yield.size;\n        // initialize the iterator\n        it = toUint8ArrayIterator(source)[Symbol.iterator]();\n        _context.prev = 10;\n      case 11:\n        // read the next value\n        _ref = isNaN(size - bufferLength) ? it.next(undefined) : it.next(size - bufferLength);\n        done = _ref.done;\n        buffer = _ref.value;\n        // if chunk is not null or empty, push it onto the queue\n        if (!done && buffer.byteLength > 0) {\n          buffers.push(buffer);\n          bufferLength += buffer.byteLength;\n        }\n        // If we have enough bytes in our buffer, yield chunks until we don't\n        if (!(done || size <= bufferLength)) {\n          _context.next = 22;\n          break;\n        }\n      case 16:\n        _context.next = 18;\n        return byteRange();\n      case 18:\n        _yield$byteRange = _context.sent;\n        cmd = _yield$byteRange.cmd;\n        size = _yield$byteRange.size;\n      case 21:\n        if (size < bufferLength) {\n          _context.next = 16;\n          break;\n        }\n      case 22:\n        if (!done) {\n          _context.next = 11;\n          break;\n        }\n      case 23:\n        _context.next = 28;\n        break;\n      case 25:\n        _context.prev = 25;\n        _context.t0 = _context[\"catch\"](10);\n        (threw = true) && typeof it.throw === 'function' && it.throw(_context.t0);\n      case 28:\n        _context.prev = 28;\n        threw === false && typeof it.return === 'function' && it.return();\n        return _context.finish(28);\n      case 31:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _marked, null, [[10, 25, 28, 31]]);\n}\n/** @ignore */\nfunction _fromAsyncIterable2(_x) {\n  return _fromAsyncIterable.apply(this, arguments);\n} // All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nfunction _fromAsyncIterable() {\n  _fromAsyncIterable = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield2, it, _ref2, _yield$byteRange2;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          byteRange = function _byteRange2() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n            var _joinUint8Arrays3 = joinUint8Arrays(buffers, size);\n            var _joinUint8Arrays4 = _slicedToArray(_joinUint8Arrays3, 3);\n            buffer = _joinUint8Arrays4[0];\n            buffers = _joinUint8Arrays4[1];\n            bufferLength = _joinUint8Arrays4[2];\n            return buffer;\n          };\n          threw = false;\n          buffers = [];\n          bufferLength = 0;\n          _context2.next = 6;\n          return null;\n        case 6:\n          _yield2 = _context2.sent;\n          cmd = _yield2.cmd;\n          size = _yield2.size;\n          // initialize the iterator\n          it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n          _context2.prev = 10;\n        case 11:\n          if (!isNaN(size - bufferLength)) {\n            _context2.next = 17;\n            break;\n          }\n          _context2.next = 14;\n          return _awaitAsyncGenerator(it.next(undefined));\n        case 14:\n          _context2.t0 = _context2.sent;\n          _context2.next = 20;\n          break;\n        case 17:\n          _context2.next = 19;\n          return _awaitAsyncGenerator(it.next(size - bufferLength));\n        case 19:\n          _context2.t0 = _context2.sent;\n        case 20:\n          _ref2 = _context2.t0;\n          done = _ref2.done;\n          buffer = _ref2.value;\n          // if chunk is not null or empty, push it onto the queue\n          if (!done && buffer.byteLength > 0) {\n            buffers.push(buffer);\n            bufferLength += buffer.byteLength;\n          }\n          // If we have enough bytes in our buffer, yield chunks until we don't\n          if (!(done || size <= bufferLength)) {\n            _context2.next = 31;\n            break;\n          }\n        case 25:\n          _context2.next = 27;\n          return byteRange();\n        case 27:\n          _yield$byteRange2 = _context2.sent;\n          cmd = _yield$byteRange2.cmd;\n          size = _yield$byteRange2.size;\n        case 30:\n          if (size < bufferLength) {\n            _context2.next = 25;\n            break;\n          }\n        case 31:\n          if (!done) {\n            _context2.next = 11;\n            break;\n          }\n        case 32:\n          _context2.next = 40;\n          break;\n        case 34:\n          _context2.prev = 34;\n          _context2.t1 = _context2[\"catch\"](10);\n          _context2.t2 = (threw = true) && typeof it.throw === 'function';\n          if (!_context2.t2) {\n            _context2.next = 40;\n            break;\n          }\n          _context2.next = 40;\n          return _awaitAsyncGenerator(it.throw(_context2.t1));\n        case 40:\n          _context2.prev = 40;\n          _context2.t3 = threw === false && typeof it.return === 'function';\n          if (!_context2.t3) {\n            _context2.next = 45;\n            break;\n          }\n          _context2.next = 45;\n          return _awaitAsyncGenerator(it.return());\n        case 45:\n          return _context2.finish(40);\n        case 46:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee, null, [[10, 34, 40, 46]]);\n  }));\n  return _fromAsyncIterable.apply(this, arguments);\n}\nfunction _fromDOMStream2(_x2) {\n  return _fromDOMStream.apply(this, arguments);\n}\n/** @ignore */\nfunction _fromDOMStream() {\n  _fromDOMStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(source) {\n    var done, threw, buffers, buffer, cmd, size, bufferLength, byteRange, _yield3, it, _ref3, _yield$byteRange3;\n    return _regeneratorRuntime().wrap(function _callee2$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          byteRange = function _byteRange3() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n            var _joinUint8Arrays5 = joinUint8Arrays(buffers, size);\n            var _joinUint8Arrays6 = _slicedToArray(_joinUint8Arrays5, 3);\n            buffer = _joinUint8Arrays6[0];\n            buffers = _joinUint8Arrays6[1];\n            bufferLength = _joinUint8Arrays6[2];\n            return buffer;\n          };\n          done = false, threw = false;\n          buffers = [];\n          bufferLength = 0;\n          _context3.next = 6;\n          return null;\n        case 6:\n          _yield3 = _context3.sent;\n          cmd = _yield3.cmd;\n          size = _yield3.size;\n          // initialize the reader and lock the stream\n          it = new AdaptiveByteReader(source);\n          _context3.prev = 10;\n        case 11:\n          if (!isNaN(size - bufferLength)) {\n            _context3.next = 17;\n            break;\n          }\n          _context3.next = 14;\n          return _awaitAsyncGenerator(it['read'](undefined));\n        case 14:\n          _context3.t0 = _context3.sent;\n          _context3.next = 20;\n          break;\n        case 17:\n          _context3.next = 19;\n          return _awaitAsyncGenerator(it['read'](size - bufferLength));\n        case 19:\n          _context3.t0 = _context3.sent;\n        case 20:\n          _ref3 = _context3.t0;\n          done = _ref3.done;\n          buffer = _ref3.value;\n          // if chunk is not null or empty, push it onto the queue\n          if (!done && buffer.byteLength > 0) {\n            buffers.push(toUint8Array(buffer));\n            bufferLength += buffer.byteLength;\n          }\n          // If we have enough bytes in our buffer, yield chunks until we don't\n          if (!(done || size <= bufferLength)) {\n            _context3.next = 31;\n            break;\n          }\n        case 25:\n          _context3.next = 27;\n          return byteRange();\n        case 27:\n          _yield$byteRange3 = _context3.sent;\n          cmd = _yield$byteRange3.cmd;\n          size = _yield$byteRange3.size;\n        case 30:\n          if (size < bufferLength) {\n            _context3.next = 25;\n            break;\n          }\n        case 31:\n          if (!done) {\n            _context3.next = 11;\n            break;\n          }\n        case 32:\n          _context3.next = 40;\n          break;\n        case 34:\n          _context3.prev = 34;\n          _context3.t1 = _context3[\"catch\"](10);\n          _context3.t2 = threw = true;\n          if (!_context3.t2) {\n            _context3.next = 40;\n            break;\n          }\n          _context3.next = 40;\n          return _awaitAsyncGenerator(it['cancel'](_context3.t1));\n        case 40:\n          _context3.prev = 40;\n          if (!(threw === false)) {\n            _context3.next = 46;\n            break;\n          }\n          _context3.next = 44;\n          return _awaitAsyncGenerator(it['cancel']());\n        case 44:\n          _context3.next = 47;\n          break;\n        case 46:\n          source['locked'] && it.releaseLock();\n        case 47:\n          return _context3.finish(40);\n        case 48:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee2, null, [[10, 34, 40, 48]]);\n  }));\n  return _fromDOMStream.apply(this, arguments);\n}\nvar AdaptiveByteReader = /*#__PURE__*/function () {\n  function AdaptiveByteReader(source) {\n    _classCallCheck(this, AdaptiveByteReader);\n    this.source = source;\n    this.byobReader = null;\n    this.defaultReader = null;\n    try {\n      this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n    } catch (e) {\n      this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n    }\n  }\n  _createClass(AdaptiveByteReader, [{\n    key: \"closed\",\n    get: function get() {\n      return this.reader ? this.reader['closed'].catch(function () {}) : Promise.resolve();\n    }\n  }, {\n    key: \"releaseLock\",\n    value: function releaseLock() {\n      if (this.reader) {\n        this.reader.releaseLock();\n      }\n      this.reader = this.byobReader = this.defaultReader = null;\n    }\n  }, {\n    key: \"cancel\",\n    value: function () {\n      var _cancel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(reason) {\n        var reader, source;\n        return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              reader = this.reader, source = this.source;\n              _context4.t0 = reader;\n              if (!_context4.t0) {\n                _context4.next = 5;\n                break;\n              }\n              _context4.next = 5;\n              return reader['cancel'](reason).catch(function () {});\n            case 5:\n              source && source['locked'] && this.releaseLock();\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee3, this);\n      }));\n      function cancel(_x4) {\n        return _cancel.apply(this, arguments);\n      }\n      return cancel;\n    }()\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(size) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(size === 0)) {\n                _context5.next = 2;\n                break;\n              }\n              return _context5.abrupt(\"return\", {\n                done: this.reader == null,\n                value: new Uint8Array(0)\n              });\n            case 2:\n              if (!(!this.supportsBYOB || typeof size !== 'number')) {\n                _context5.next = 8;\n                break;\n              }\n              _context5.next = 5;\n              return this.getDefaultReader().read();\n            case 5:\n              _context5.t0 = _context5.sent;\n              _context5.next = 11;\n              break;\n            case 8:\n              _context5.next = 10;\n              return this.readFromBYOBReader(size);\n            case 10:\n              _context5.t0 = _context5.sent;\n            case 11:\n              result = _context5.t0;\n              !result.done && (result.value = toUint8Array(result));\n              return _context5.abrupt(\"return\", result);\n            case 14:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee4, this);\n      }));\n      function read(_x5) {\n        return _read.apply(this, arguments);\n      }\n      return read;\n    }()\n  }, {\n    key: \"getDefaultReader\",\n    value: function getDefaultReader() {\n      if (this.byobReader) {\n        this.releaseLock();\n      }\n      if (!this.defaultReader) {\n        this.defaultReader = this.source['getReader']();\n        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n        this.defaultReader['closed'].catch(function () {});\n      }\n      return this.reader = this.defaultReader;\n    }\n  }, {\n    key: \"getBYOBReader\",\n    value: function getBYOBReader() {\n      if (this.defaultReader) {\n        this.releaseLock();\n      }\n      if (!this.byobReader) {\n        this.byobReader = this.source['getReader']({\n          mode: 'byob'\n        });\n        // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n        // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n        // about why these errors are raised, but I'm sure there's some important spec reason that\n        // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n        // only solution in this case :/\n        this.byobReader['closed'].catch(function () {});\n      }\n      return this.reader = this.byobReader;\n    }\n    // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n  }, {\n    key: \"readFromBYOBReader\",\n    value: function () {\n      var _readFromBYOBReader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(size) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n            case 2:\n              return _context6.abrupt(\"return\", _context6.sent);\n            case 3:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee5, this);\n      }));\n      function readFromBYOBReader(_x6) {\n        return _readFromBYOBReader.apply(this, arguments);\n      }\n      return readFromBYOBReader;\n    }()\n  }]);\n  return AdaptiveByteReader;\n}();\n/** @ignore */\nfunction readInto(_x7, _x8, _x9, _x10) {\n  return _readInto.apply(this, arguments);\n}\n/** @ignore */\nfunction _readInto() {\n  _readInto = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(reader, buffer, offset, size) {\n    var _yield$reader$read, done, value;\n    return _regeneratorRuntime().wrap(function _callee8$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          if (!(offset >= size)) {\n            _context9.next = 2;\n            break;\n          }\n          return _context9.abrupt(\"return\", {\n            done: false,\n            value: new Uint8Array(buffer, 0, size)\n          });\n        case 2:\n          _context9.next = 4;\n          return reader.read(new Uint8Array(buffer, offset, size - offset));\n        case 4:\n          _yield$reader$read = _context9.sent;\n          done = _yield$reader$read.done;\n          value = _yield$reader$read.value;\n          if (!((offset += value.byteLength) < size && !done)) {\n            _context9.next = 11;\n            break;\n          }\n          _context9.next = 10;\n          return readInto(reader, value.buffer, offset, size);\n        case 10:\n          return _context9.abrupt(\"return\", _context9.sent);\n        case 11:\n          return _context9.abrupt(\"return\", {\n            done: done,\n            value: new Uint8Array(value.buffer, 0, offset)\n          });\n        case 12:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee8);\n  }));\n  return _readInto.apply(this, arguments);\n}\nvar onEvent = function onEvent(stream, event) {\n  var handler = function handler(_) {\n    return resolve([event, _]);\n  };\n  var resolve;\n  return [event, handler, new Promise(function (r) {\n    return (resolve = r) && stream['once'](event, handler);\n  })];\n};\n/** @ignore */\nfunction _fromNodeStream2(_x3) {\n  return _fromNodeStream.apply(this, arguments);\n}\nfunction _fromNodeStream() {\n  _fromNodeStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(stream) {\n    var events, event, done, err, cmd, size, bufferLength, buffers, buffer, byteRange, _yield4, _yield$_awaitAsyncGen, _yield$_awaitAsyncGen2, _yield$byteRange4, cleanup;\n    return _regeneratorRuntime().wrap(function _callee7$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          cleanup = function _cleanup(events, err) {\n            buffer = buffers = null;\n            return new Promise( /*#__PURE__*/function () {\n              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(resolve, reject) {\n                var _iterator, _step, _step$value, evt, fn, destroy;\n                return _regeneratorRuntime().wrap(function _callee6$(_context7) {\n                  while (1) switch (_context7.prev = _context7.next) {\n                    case 0:\n                      _iterator = _createForOfIteratorHelper(events);\n                      try {\n                        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                          _step$value = _slicedToArray(_step.value, 2), evt = _step$value[0], fn = _step$value[1];\n                          stream['off'](evt, fn);\n                        }\n                      } catch (err) {\n                        _iterator.e(err);\n                      } finally {\n                        _iterator.f();\n                      }\n                      try {\n                        // Some stream implementations don't call the destroy callback,\n                        // because it's really a node-internal API. Just calling `destroy`\n                        // here should be enough to conform to the ReadableStream contract\n                        destroy = stream['destroy'];\n                        destroy && destroy.call(stream, err);\n                        err = undefined;\n                      } catch (e) {\n                        err = e || err;\n                      } finally {\n                        err != null ? reject(err) : resolve();\n                      }\n                    case 3:\n                    case \"end\":\n                      return _context7.stop();\n                  }\n                }, _callee6);\n              }));\n              return function (_x11, _x12) {\n                return _ref4.apply(this, arguments);\n              };\n            }());\n          };\n          byteRange = function _byteRange4() {\n            if (cmd === 'peek') {\n              return joinUint8Arrays(buffers, size)[0];\n            }\n            var _joinUint8Arrays7 = joinUint8Arrays(buffers, size);\n            var _joinUint8Arrays8 = _slicedToArray(_joinUint8Arrays7, 3);\n            buffer = _joinUint8Arrays8[0];\n            buffers = _joinUint8Arrays8[1];\n            bufferLength = _joinUint8Arrays8[2];\n            return buffer;\n          };\n          events = [];\n          event = 'error';\n          done = false, err = null;\n          bufferLength = 0;\n          buffers = [];\n          _context8.next = 9;\n          return null;\n        case 9:\n          _yield4 = _context8.sent;\n          cmd = _yield4.cmd;\n          size = _yield4.size;\n          if (!stream['isTTY']) {\n            _context8.next = 16;\n            break;\n          }\n          _context8.next = 15;\n          return new Uint8Array(0);\n        case 15:\n          return _context8.abrupt(\"return\", _context8.sent);\n        case 16:\n          _context8.prev = 16;\n          // initialize the stream event handlers\n          events[0] = onEvent(stream, 'end');\n          events[1] = onEvent(stream, 'error');\n        case 19:\n          events[2] = onEvent(stream, 'readable');\n          // wait on the first message event from the stream\n          _context8.next = 22;\n          return _awaitAsyncGenerator(Promise.race(events.map(function (x) {\n            return x[2];\n          })));\n        case 22:\n          _yield$_awaitAsyncGen = _context8.sent;\n          _yield$_awaitAsyncGen2 = _slicedToArray(_yield$_awaitAsyncGen, 2);\n          event = _yield$_awaitAsyncGen2[0];\n          err = _yield$_awaitAsyncGen2[1];\n          if (!(event === 'error')) {\n            _context8.next = 28;\n            break;\n          }\n          return _context8.abrupt(\"break\", 37);\n        case 28:\n          if (!(done = event === 'end')) {\n            // If the size is NaN, request to read everything in the stream's internal buffer\n            if (!isFinite(size - bufferLength)) {\n              buffer = toUint8Array(stream['read'](undefined));\n            } else {\n              buffer = toUint8Array(stream['read'](size - bufferLength));\n              // If the byteLength is 0, then the requested amount is more than the stream has\n              // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n              // continue emitting readable events, so request to read everything the stream\n              // has in its internal buffer right now.\n              if (buffer.byteLength < size - bufferLength) {\n                buffer = toUint8Array(stream['read'](undefined));\n              }\n            }\n            // if chunk is not null or empty, push it onto the queue\n            if (buffer.byteLength > 0) {\n              buffers.push(buffer);\n              bufferLength += buffer.byteLength;\n            }\n          }\n          // If we have enough bytes in our buffer, yield chunks until we don't\n          if (!(done || size <= bufferLength)) {\n            _context8.next = 36;\n            break;\n          }\n        case 30:\n          _context8.next = 32;\n          return byteRange();\n        case 32:\n          _yield$byteRange4 = _context8.sent;\n          cmd = _yield$byteRange4.cmd;\n          size = _yield$byteRange4.size;\n        case 35:\n          if (size < bufferLength) {\n            _context8.next = 30;\n            break;\n          }\n        case 36:\n          if (!done) {\n            _context8.next = 19;\n            break;\n          }\n        case 37:\n          _context8.prev = 37;\n          _context8.next = 40;\n          return _awaitAsyncGenerator(cleanup(events, event === 'error' ? err : null));\n        case 40:\n          return _context8.finish(37);\n        case 41:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee7, null, [[16,, 37, 41]]);\n  }));\n  return _fromNodeStream.apply(this, arguments);\n}","map":{"version":3,"sources":["io/adapters.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport {\n    toUint8Array,\n    joinUint8Arrays,\n    ArrayBufferViewInput,\n    toUint8ArrayIterator,\n    toUint8ArrayAsyncIterator\n} from '../util/buffer';\n\nimport { ReadableDOMStreamOptions } from './interfaces';\n\n/** @ignore */\nexport default {\n    fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n        return pump(fromIterable<T>(source));\n    },\n    fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromAsyncIterable<T>(source));\n    },\n    fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n        return pump(fromDOMStream<T>(source));\n    },\n    fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n        return pump(fromNodeStream(stream));\n    },\n    // @ts-ignore\n    toDOMStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: ReadableDOMStreamOptions): ReadableStream<T> {\n        throw new Error(`\"toDOMStream\" not available in this environment`);\n    },\n    // @ts-ignore\n    toNodeStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: import('stream').ReadableOptions): import('stream').Readable {\n        throw new Error(`\"toNodeStream\" not available in this environment`);\n    },\n};\n\n/** @ignore */\nconst pump = <T extends Iterator<any> | AsyncIterator<any>>(iterator: T) => { iterator.next(); return iterator; };\n\n/** @ignore */\nfunction* fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): IterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source Iterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayIterator(source)[Symbol.iterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength) ?\n                it.next(undefined) : it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (it.return());\n    }\n}\n\n/** @ignore */\nasync function* fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done: boolean, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source AsyncIterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    let it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it.next(undefined)\n                : await it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (await it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (await it.return());\n    }\n}\n\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nasync function* fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncIterableIterator<Uint8Array> {\n\n    let done = false, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we establish the ReadableStream lock\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the reader and lock the stream\n    let it = new AdaptiveByteReader(source);\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it['read'](undefined)\n                : await it['read'](size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(toUint8Array(buffer));\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (await it['cancel'](e));\n    } finally {\n        (threw === false) ? (await it['cancel']())\n            : source['locked'] && it.releaseLock();\n    }\n}\n\n/** @ignore */\nclass AdaptiveByteReader<T extends ArrayBufferViewInput> {\n\n    private supportsBYOB: boolean;\n    private byobReader: ReadableStreamBYOBReader | null = null;\n    private defaultReader: ReadableStreamDefaultReader<T> | null = null;\n    private reader: ReadableStreamBYOBReader | ReadableStreamDefaultReader<T> | null;\n\n    constructor(private source: ReadableStream<T>) {\n        try {\n            this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n        } catch (e) {\n            this.supportsBYOB = !!!(this.reader = this.getDefaultReader());\n        }\n    }\n\n    get closed(): Promise<void> {\n        return this.reader ? this.reader['closed'].catch(() => {}) : Promise.resolve();\n    }\n\n    releaseLock(): void {\n        if (this.reader) {\n            this.reader.releaseLock();\n        }\n        this.reader = this.byobReader = this.defaultReader = null;\n    }\n\n    async cancel(reason?: any): Promise<void> {\n        const { reader, source } = this;\n        reader && (await reader['cancel'](reason).catch(() => {}));\n        source && (source['locked'] && this.releaseLock());\n    }\n\n    async read(size?: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n        if (size === 0) {\n            return { done: this.reader == null, value: new Uint8Array(0) };\n        }\n        const result = !this.supportsBYOB || typeof size !== 'number'\n            ? await this.getDefaultReader().read()\n            : await this.readFromBYOBReader(size);\n        !result.done && (result.value = toUint8Array(result as ReadableStreamReadResult<Uint8Array>));\n        return result as ReadableStreamReadResult<Uint8Array>;\n    }\n\n    private getDefaultReader() {\n        if (this.byobReader) { this.releaseLock(); }\n        if (!this.defaultReader) {\n            this.defaultReader = this.source['getReader']();\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.defaultReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.defaultReader);\n    }\n\n    private getBYOBReader() {\n        if (this.defaultReader) { this.releaseLock(); }\n        if (!this.byobReader) {\n            this.byobReader = this.source['getReader']({ mode: 'byob' });\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.byobReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.byobReader);\n    }\n\n    // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n    private async readFromBYOBReader(size: number) {\n        return await readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n    }\n}\n\n/** @ignore */\nasync function readInto(reader: ReadableStreamBYOBReader, buffer: ArrayBufferLike, offset: number, size: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n    if (offset >= size) {\n        return { done: false, value: new Uint8Array(buffer, 0, size) };\n    }\n    const { done, value } = await reader.read(new Uint8Array(buffer, offset, size - offset));\n    if (((offset += value.byteLength) < size) && !done) {\n        return await readInto(reader, value.buffer, offset, size);\n    }\n    return { done, value: new Uint8Array(value.buffer, 0, offset) };\n}\n\n/** @ignore */\ntype EventName = 'end' | 'error' | 'readable';\n/** @ignore */\ntype Event = [EventName, (_: any) => void, Promise<[EventName, Error | null]>];\n/** @ignore */\nconst onEvent = <T extends string>(stream: NodeJS.ReadableStream, event: T) => {\n    let handler = (_: any) => resolve([event, _]);\n    let resolve: (value?: [T, any] | PromiseLike<[T, any]>) => void;\n    return [event, handler, new Promise<[T, any]>(\n        (r) => (resolve = r) && stream['once'](event, handler)\n    )] as Event;\n};\n\n/** @ignore */\nasync function* fromNodeStream(stream: NodeJS.ReadableStream): AsyncIterableIterator<Uint8Array> {\n\n    let events: Event[] = [];\n    let event: EventName = 'error';\n    let done = false, err: Error | null = null;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array | Buffer | string;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we\n    // add the listener for the source stream's 'readable' event.\n    ({ cmd, size } = yield <any> null);\n\n    // ignore stdin if it's a TTY\n    if ((stream as any)['isTTY']) { return yield new Uint8Array(0); }\n\n    try {\n        // initialize the stream event handlers\n        events[0] = onEvent(stream, 'end');\n        events[1] = onEvent(stream, 'error');\n\n        do {\n            events[2] = onEvent(stream, 'readable');\n\n            // wait on the first message event from the stream\n            [event, err] = await Promise.race(events.map((x) => x[2]));\n\n            // if the stream emitted an Error, rethrow it\n            if (event === 'error') { break; }\n            if (!(done = event === 'end')) {\n                // If the size is NaN, request to read everything in the stream's internal buffer\n                if (!isFinite(size - bufferLength)) {\n                    buffer = toUint8Array(stream['read'](undefined));\n                } else {\n                    buffer = toUint8Array(stream['read'](size - bufferLength));\n                    // If the byteLength is 0, then the requested amount is more than the stream has\n                    // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                    // continue emitting readable events, so request to read everything the stream\n                    // has in its internal buffer right now.\n                    if (buffer.byteLength < (size - bufferLength)) {\n                        buffer = toUint8Array(stream['read'](undefined));\n                    }\n                }\n                // if chunk is not null or empty, push it onto the queue\n                if (buffer.byteLength > 0) {\n                    buffers.push(buffer);\n                    bufferLength += buffer.byteLength;\n                }\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } finally {\n        await cleanup(events, event === 'error' ? err : null);\n    }\n\n    function cleanup<T extends Error | null | void>(events: Event[], err?: T) {\n        buffer = buffers = <any> null;\n        return new Promise<T>(async (resolve, reject) => {\n            for (const [evt, fn] of events) {\n                stream['off'](evt, fn);\n            }\n            try {\n                // Some stream implementations don't call the destroy callback,\n                // because it's really a node-internal API. Just calling `destroy`\n                // here should be enough to conform to the ReadableStream contract\n                const destroy = (stream as any)['destroy'];\n                destroy && destroy.call(stream, err);\n                err = undefined;\n            } catch (e) { err = e || err; } finally {\n                err != null ? reject(err) : resolve();\n            }\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}